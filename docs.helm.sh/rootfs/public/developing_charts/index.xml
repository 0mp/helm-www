<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Developing_charts</title>
    <link>https://docs.helm.sh/developing_charts/</link>
    <language>en-us</language>
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title></title>
      <link>https://docs.helm.sh/developing_charts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
      <guid>https://docs.helm.sh/developing_charts/</guid>
      <description>

&lt;h1 id=&#34;charts&#34;&gt;Charts&lt;/h1&gt;

&lt;p&gt;Helm uses a packaging format called &lt;em&gt;charts&lt;/em&gt;. A chart is a collection of files
that describe a related set of Kubernetes resources. A single chart
might be used to deploy something simple, like a memcached pod, or
something complex, like a full web app stack with HTTP servers,
databases, caches, and so on.&lt;/p&gt;

&lt;p&gt;Charts are created as files laid out in a particular directory tree,
then they can be packaged into versioned archives to be deployed.&lt;/p&gt;

&lt;p&gt;This document explains the chart format, and provides basic guidance for
building charts with Helm.&lt;/p&gt;

&lt;h2 id=&#34;the-chart-file-structure&#34;&gt;The Chart File Structure&lt;/h2&gt;

&lt;p&gt;A chart is organized as a collection of files inside of a directory. The
directory name is the name of the chart (without versioning information). Thus,
a chart describing WordPress would be stored in the &lt;code&gt;wordpress/&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;Inside of this directory, Helm will expect a structure that matches this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wordpress/
  Chart.yaml          # A YAML file containing information about the chart
  LICENSE             # OPTIONAL: A plain text file containing the license for the chart
  README.md           # OPTIONAL: A human-readable README file
  requirements.yaml   # OPTIONAL: A YAML file listing dependencies for the chart
  values.yaml         # The default configuration values for this chart
  charts/             # OPTIONAL: A directory containing any charts upon which this chart depends.
  templates/          # OPTIONAL: A directory of templates that, when combined with values,
                      # will generate valid Kubernetes manifest files.
  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helm reserves use of the &lt;code&gt;charts/&lt;/code&gt; and &lt;code&gt;templates/&lt;/code&gt; directories, and of
the listed file names. Other files will be left as they are.&lt;/p&gt;

&lt;p&gt;While the &lt;code&gt;charts&lt;/code&gt; and &lt;code&gt;templates&lt;/code&gt; directories are optional there must be at least one chart dependency or template file for the chart to be valid.&lt;/p&gt;

&lt;h2 id=&#34;the-chart-yaml-file&#34;&gt;The Chart.yaml File&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Chart.yaml&lt;/code&gt; file is required for a chart. It contains the following fields:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: The name of the chart (required)
version: A SemVer 2 version (required)
description: A single-sentence description of this project (optional)
keywords:
  - A list of keywords about this project (optional)
home: The URL of this project&#39;s home page (optional)
sources:
  - A list of URLs to source code for this project (optional)
maintainers: # (optional)
  - name: The maintainer&#39;s name (required for each maintainer)
    email: The maintainer&#39;s email (optional for each maintainer)
    url: A URL for the maintainer (optional for each maintainer)
engine: gotpl # The name of the template engine (optional, defaults to gotpl)
icon: A URL to an SVG or PNG image to be used as an icon (optional).
appVersion: The version of the app that this contains (optional). This needn&#39;t be SemVer.
deprecated: Whether this chart is deprecated (optional, boolean)
tillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer range: &amp;quot;&amp;gt;2.0.0&amp;quot; (optional)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you are familiar with the &lt;code&gt;Chart.yaml&lt;/code&gt; file format for Helm Classic, you will
notice that fields specifying dependencies have been removed. That is because
the new Chart format expresses dependencies using the &lt;code&gt;charts/&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;Other fields will be silently ignored.&lt;/p&gt;

&lt;h3 id=&#34;charts-and-versioning&#34;&gt;Charts and Versioning&lt;/h3&gt;

&lt;p&gt;Every chart must have a version number. A version must follow the
&lt;a href=&#34;http://semver.org/&#34;&gt;SemVer 2&lt;/a&gt; standard. Unlike Helm Classic, Kubernetes
Helm uses version numbers as release markers. Packages in repositories
are identified by name plus version.&lt;/p&gt;

&lt;p&gt;For example, an &lt;code&gt;nginx&lt;/code&gt; chart whose version field is set to &lt;code&gt;version:
1.2.3&lt;/code&gt; will be named:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nginx-1.2.3.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More complex SemVer 2 names are also supported, such as
&lt;code&gt;version: 1.2.3-alpha.1+ef365&lt;/code&gt;. But non-SemVer names are explicitly
disallowed by the system.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Whereas Helm Classic and Deployment Manager were both
very GitHub oriented when it came to charts, Kubernetes Helm does not
rely upon or require GitHub or even Git. Consequently, it does not use
Git SHAs for versioning at all.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;version&lt;/code&gt; field inside of the &lt;code&gt;Chart.yaml&lt;/code&gt; is used by many of the
Helm tools, including the CLI and the Tiller server. When generating a
package, the &lt;code&gt;helm package&lt;/code&gt; command will use the version that it finds
in the &lt;code&gt;Chart.yaml&lt;/code&gt; as a token in the package name. The system assumes
that the version number in the chart package name matches the version number in
the &lt;code&gt;Chart.yaml&lt;/code&gt;. Failure to meet this assumption will cause an error.&lt;/p&gt;

&lt;h3 id=&#34;the-appversion-field&#34;&gt;The appVersion field&lt;/h3&gt;

&lt;p&gt;Note that the &lt;code&gt;appVersion&lt;/code&gt; field is not related to the &lt;code&gt;version&lt;/code&gt; field. It is
a way of specifying the version of the application. For example, the &lt;code&gt;drupal&lt;/code&gt;
chart may have an &lt;code&gt;appVersion: 8.2.1&lt;/code&gt;, indicating that the version of Drupal
included in the chart (by default) is &lt;code&gt;8.2.1&lt;/code&gt;. This field is informational, and
has no impact on chart version calculations.&lt;/p&gt;

&lt;h3 id=&#34;deprecating-charts&#34;&gt;Deprecating Charts&lt;/h3&gt;

&lt;p&gt;When managing charts in a Chart Repository, it is sometimes necessary to
deprecate a chart. The optional &lt;code&gt;deprecated&lt;/code&gt; field in &lt;code&gt;Chart.yaml&lt;/code&gt; can be used
to mark a chart as deprecated. If the &lt;strong&gt;latest&lt;/strong&gt; version of a chart in the
repository is marked as deprecated, then the chart as a whole is considered to
be deprecated. The chart name can later be reused by publishing a newer version
that is not marked as deprecated. The workflow for deprecating charts, as
followed by the &lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;kubernetes/charts&lt;/a&gt;
project is:
  - Update chart&amp;rsquo;s &lt;code&gt;Chart.yaml&lt;/code&gt; to mark the chart as deprecated, bumping the
  version
  - Release the new chart version in the Chart Repository
  - Remove the chart from the source repository (e.g. git)&lt;/p&gt;

&lt;h2 id=&#34;chart-license-readme-and-notes&#34;&gt;Chart LICENSE, README and NOTES&lt;/h2&gt;

&lt;p&gt;Charts can also contain files that describe the installation, configuration, usage and license of a
chart. A README for a chart should be formatted in Markdown (README.md), and should generally
contain:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A description of the application or service the chart provides&lt;/li&gt;
&lt;li&gt;Any prerequisites or requirements to run the chart&lt;/li&gt;
&lt;li&gt;Descriptions of options in &lt;code&gt;values.yaml&lt;/code&gt; and default values&lt;/li&gt;
&lt;li&gt;Any other information that may be relevant to the installation or configuration of the chart&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The chart can also contain a short plain text &lt;code&gt;templates/NOTES.txt&lt;/code&gt; file that will be printed out
after installation, and when viewing the status of a release. This file is evaluated as a
&lt;a href=&#34;#templates-and-values&#34;&gt;template&lt;/a&gt;, and can be used to display usage notes, next steps, or any other
information relevant to a release of the chart. For example, instructions could be provided for
connecting to a database, or accessing a web UI. Since this file is printed to STDOUT when running
&lt;code&gt;helm install&lt;/code&gt; or &lt;code&gt;helm status&lt;/code&gt;, it is recommended to keep the content brief and point to the README
for greater detail.&lt;/p&gt;

&lt;h2 id=&#34;chart-dependencies&#34;&gt;Chart Dependencies&lt;/h2&gt;

&lt;p&gt;In Helm, one chart may depend on any number of other charts.
These dependencies can be dynamically linked through the &lt;code&gt;requirements.yaml&lt;/code&gt;
file or brought in to the &lt;code&gt;charts/&lt;/code&gt; directory and managed manually.&lt;/p&gt;

&lt;p&gt;Although manually managing your dependencies has a few advantages some teams need,
the preferred method of declaring dependencies is by using a
&lt;code&gt;requirements.yaml&lt;/code&gt; file inside of your chart.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;dependencies:&lt;/code&gt; section of the &lt;code&gt;Chart.yaml&lt;/code&gt; from Helm
Classic has been completely removed.&lt;/p&gt;

&lt;h3 id=&#34;managing-dependencies-with-requirements-yaml&#34;&gt;Managing Dependencies with &lt;code&gt;requirements.yaml&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;code&gt;requirements.yaml&lt;/code&gt; file is a simple file for listing your
dependencies.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;dependencies:
  - name: apache
    version: 1.2.3
    repository: http://example.com/charts
  - name: mysql
    version: 3.2.1
    repository: http://another.example.com/charts
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;name&lt;/code&gt; field is the name of the chart you want.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;version&lt;/code&gt; field is the version of the chart you want.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;repository&lt;/code&gt; field is the full URL to the chart repository. Note
that you must also use &lt;code&gt;helm repo add&lt;/code&gt; to add that repo locally.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Once you have a dependencies file, you can run &lt;code&gt;helm dependency update&lt;/code&gt;
and it will use your dependency file to download all the specified
charts into your &lt;code&gt;charts/&lt;/code&gt; directory for you.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm dep up foochart
Hang tight while we grab the latest from your chart repositories...
...Successfully got an update from the &amp;quot;local&amp;quot; chart repository
...Successfully got an update from the &amp;quot;stable&amp;quot; chart repository
...Successfully got an update from the &amp;quot;example&amp;quot; chart repository
...Successfully got an update from the &amp;quot;another&amp;quot; chart repository
Update Complete. Happy Helming!
Saving 2 charts
Downloading apache from repo http://example.com/charts
Downloading mysql from repo http://another.example.com/charts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;helm dependency update&lt;/code&gt; retrieves charts, it will store them as
chart archives in the &lt;code&gt;charts/&lt;/code&gt; directory. So for the example above, one
would expect to see the following files in the charts directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;charts/
  apache-1.2.3.tgz
  mysql-3.2.1.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Managing charts with &lt;code&gt;requirements.yaml&lt;/code&gt; is a good way to easily keep
charts updated, and also share requirements information throughout a
team.&lt;/p&gt;

&lt;h4 id=&#34;alias-field-in-requirements-yaml&#34;&gt;Alias field in requirements.yaml&lt;/h4&gt;

&lt;p&gt;In addition to the other fields above, each requirements entry may contain
the optional field &lt;code&gt;alias&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Adding an alias for a dependency chart would put
a chart in dependencies using alias as name of new dependency.&lt;/p&gt;

&lt;p&gt;One can use &lt;code&gt;alias&lt;/code&gt; in cases where they need to access a chart
with other name(s).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# parentchart/requirements.yaml
dependencies:
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-1
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
    alias: new-subchart-2
  - name: subchart
    repository: http://localhost:10191
    version: 0.1.0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example we will get 3 dependencies in all for &lt;code&gt;parentchart&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;subchart
new-subchart-1
new-subchart-2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The manual way of achieving this is by copy/pasting the same chart in the
&lt;code&gt;charts/&lt;/code&gt; directory multiple times with different names.&lt;/p&gt;

&lt;h4 id=&#34;tags-and-condition-fields-in-requirements-yaml&#34;&gt;Tags and Condition fields in requirements.yaml&lt;/h4&gt;

&lt;p&gt;In addition to the other fields above, each requirements entry may contain
the optional fields &lt;code&gt;tags&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;All charts are loaded by default. If &lt;code&gt;tags&lt;/code&gt; or &lt;code&gt;condition&lt;/code&gt; fields are present,
they will be evaluated and used to control loading for the chart(s) they are applied to.&lt;/p&gt;

&lt;p&gt;Condition - The condition field holds one or more YAML paths (delimited by commas).
If this path exists in the top parent&amp;rsquo;s values and resolves to a boolean value,
the chart will be enabled or disabled based on that boolean value.  Only the first
valid path found in the list is evaluated and if no paths exist then the condition has no effect.&lt;/p&gt;

&lt;p&gt;Tags - The tags field is a YAML list of labels to associate with this chart.
In the top parent&amp;rsquo;s values, all charts with tags can be enabled or disabled by
specifying the tag and a boolean value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# parentchart/requirements.yaml
dependencies:
      - name: subchart1
        repository: http://localhost:10191
        version: 0.1.0
        condition: subchart1.enabled, global.subchart1.enabled
        tags:
          - front-end
          - subchart1

      - name: subchart2
        repository: http://localhost:10191
        version: 0.1.0
        condition: subchart2.enabled,global.subchart2.enabled
        tags:
          - back-end
          - subchart2

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# parentchart/values.yaml

subchart1:
  enabled: true
tags:
  front-end: false
  back-end: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example all charts with the tag &lt;code&gt;front-end&lt;/code&gt; would be disabled but since the
&lt;code&gt;subchart1.enabled&lt;/code&gt; path evaluates to &amp;lsquo;true&amp;rsquo; in the parent&amp;rsquo;s values, the condition will override the
&lt;code&gt;front-end&lt;/code&gt; tag and &lt;code&gt;subchart1&lt;/code&gt; will be enabled.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;subchart2&lt;/code&gt; is tagged with &lt;code&gt;back-end&lt;/code&gt; and that tag evaluates to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;subchart2&lt;/code&gt; will be
enabled. Also notes that although &lt;code&gt;subchart2&lt;/code&gt; has a condition specified in &lt;code&gt;requirements.yaml&lt;/code&gt;, there
is no corresponding path and value in the parent&amp;rsquo;s values so that condition has no effect.&lt;/p&gt;

&lt;h5 id=&#34;using-the-cli-with-tags-and-conditions&#34;&gt;Using the CLI with Tags and Conditions&lt;/h5&gt;

&lt;p&gt;The &lt;code&gt;--set&lt;/code&gt; parameter can be used as usual to alter tag and condition values.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;helm install --set tags.front-end=true --set subchart2.enabled=false

&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;tags-and-condition-resolution&#34;&gt;Tags and Condition Resolution&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Conditions (when set in values) always override tags.&lt;/strong&gt; The first condition
path that exists wins and subsequent ones for that chart are ignored.&lt;/li&gt;
&lt;li&gt;Tags are evaluated as &amp;lsquo;if any of the chart&amp;rsquo;s tags are true then enable the chart&amp;rsquo;.&lt;/li&gt;
&lt;li&gt;Tags and conditions values must be set in the top parent&amp;rsquo;s values.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;tags:&lt;/code&gt; key in values must be a top level key. Globals and nested &lt;code&gt;tags:&lt;/code&gt; tables
are not currently supported.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;importing-child-values-via-requirements-yaml&#34;&gt;Importing Child Values via requirements.yaml&lt;/h4&gt;

&lt;p&gt;In some cases it is desirable to allow a child chart&amp;rsquo;s values to propagate to the parent chart and be
shared as common defaults. An additional benefit of using the &lt;code&gt;exports&lt;/code&gt; format is that it will enable future
tooling to introspect user-settable values.&lt;/p&gt;

&lt;p&gt;The keys containing the values to be imported can be specified in the parent chart&amp;rsquo;s &lt;code&gt;requirements.yaml&lt;/code&gt; file
using a YAML list. Each item in the list is a key which is imported from the child chart&amp;rsquo;s &lt;code&gt;exports&lt;/code&gt; field.&lt;/p&gt;

&lt;p&gt;To import values not contained in the &lt;code&gt;exports&lt;/code&gt; key, use the &lt;a href=&#34;#using-the-child-parent-format&#34;&gt;child-parent&lt;/a&gt; format.
Examples of both formats are described below.&lt;/p&gt;

&lt;h5 id=&#34;using-the-exports-format&#34;&gt;Using the exports format&lt;/h5&gt;

&lt;p&gt;If a child chart&amp;rsquo;s &lt;code&gt;values.yaml&lt;/code&gt; file contains an &lt;code&gt;exports&lt;/code&gt; field at the root, its contents may be imported
directly into the parent&amp;rsquo;s values by specifying the keys to import as in the example below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# parent&#39;s requirements.yaml file
    ...
    import-values:
      - data
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# child&#39;s values.yaml file
...
exports:
  data:
    myint: 99
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since we are specifying the key &lt;code&gt;data&lt;/code&gt; in our import list, Helm looks in the &lt;code&gt;exports&lt;/code&gt; field of the child
chart for &lt;code&gt;data&lt;/code&gt; key and imports its contents.&lt;/p&gt;

&lt;p&gt;The final parent values would contain our exported field:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# parent&#39;s values file
...
myint: 99

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Please note the parent key &lt;code&gt;data&lt;/code&gt; is not contained in the parent&amp;rsquo;s final values. If you need to specify the
parent key, use the &amp;lsquo;child-parent&amp;rsquo; format.&lt;/p&gt;

&lt;h5 id=&#34;using-the-child-parent-format&#34;&gt;Using the child-parent format&lt;/h5&gt;

&lt;p&gt;To access values that are not contained in the &lt;code&gt;exports&lt;/code&gt; key of the child chart&amp;rsquo;s values, you will need to
specify the source key of the values to be imported (&lt;code&gt;child&lt;/code&gt;) and the destination path in the parent chart&amp;rsquo;s
values (&lt;code&gt;parent&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;import-values&lt;/code&gt; in the example below instructs Helm to take any values found at &lt;code&gt;child:&lt;/code&gt; path and copy them
to the parent&amp;rsquo;s values at the path specified in &lt;code&gt;parent:&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# parent&#39;s requirements.yaml file
dependencies:
  - name: subchart1
    repository: http://localhost:10191
    version: 0.1.0
    ...
    import-values:
      - child: default.data
        parent: myimports
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the above example, values found at &lt;code&gt;default.data&lt;/code&gt; in the subchart1&amp;rsquo;s values will be imported
to the &lt;code&gt;myimports&lt;/code&gt; key in the parent chart&amp;rsquo;s values as detailed below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# parent&#39;s values.yaml file

myimports:
  myint: 0
  mybool: false
  mystring: &amp;quot;helm rocks!&amp;quot;
  
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# subchart1&#39;s values.yaml file

default:
  data:
    myint: 999
    mybool: true
    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parent chart&amp;rsquo;s resulting values would be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# parent&#39;s final values

myimports:
  myint: 999
  mybool: true
  mystring: &amp;quot;helm rocks!&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parent&amp;rsquo;s final values now contains the &lt;code&gt;myint&lt;/code&gt; and &lt;code&gt;mybool&lt;/code&gt; fields imported from subchart1.&lt;/p&gt;

&lt;h3 id=&#34;managing-dependencies-manually-via-the-charts-directory&#34;&gt;Managing Dependencies manually via the &lt;code&gt;charts/&lt;/code&gt; directory&lt;/h3&gt;

&lt;p&gt;If more control over dependencies is desired, these dependencies can
be expressed explicitly by copying the dependency charts into the
&lt;code&gt;charts/&lt;/code&gt; directory.&lt;/p&gt;

&lt;p&gt;A dependency can be either a chart archive (&lt;code&gt;foo-1.2.3.tgz&lt;/code&gt;) or an
unpacked chart directory. But its name cannot start with &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt;.
Such files are ignored by the chart loader.&lt;/p&gt;

&lt;p&gt;For example, if the WordPress chart depends on the Apache chart, the
Apache chart (of the correct version) is supplied in the WordPress
chart&amp;rsquo;s &lt;code&gt;charts/&lt;/code&gt; directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wordpress:
  Chart.yaml
  requirements.yaml
  # ...
  charts/
    apache/
      Chart.yaml
      # ...
    mysql/
      Chart.yaml
      # ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above shows how the WordPress chart expresses its dependency
on Apache and MySQL by including those charts inside of its &lt;code&gt;charts/&lt;/code&gt;
directory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TIP:&lt;/strong&gt; &lt;em&gt;To drop a dependency into your &lt;code&gt;charts/&lt;/code&gt; directory, use the
&lt;code&gt;helm fetch&lt;/code&gt; command&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;operational-aspects-of-using-dependencies&#34;&gt;Operational aspects of using dependencies&lt;/h3&gt;

&lt;p&gt;The above sections explain how to specify chart dependencies, but how does this affect
chart installation using &lt;code&gt;helm install&lt;/code&gt; and &lt;code&gt;helm upgrade&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Suppose that a chart named &amp;ldquo;A&amp;rdquo; creates the following Kubernetes objects&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;namespace &amp;ldquo;A-Namespace&amp;rdquo;&lt;/li&gt;
&lt;li&gt;statefulset &amp;ldquo;A-StatefulSet&amp;rdquo;&lt;/li&gt;
&lt;li&gt;service &amp;ldquo;A-Service&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Furthermore, A is dependent on chart B that creates objects&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;namespace &amp;ldquo;B-Namespace&amp;rdquo;&lt;/li&gt;
&lt;li&gt;replicaset &amp;ldquo;B-ReplicaSet&amp;rdquo;&lt;/li&gt;
&lt;li&gt;service &amp;ldquo;B-Service&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After installation/upgrade of chart A a single Helm release is created/modified. The release will
create/update all of the above Kubernetes objects in the following order:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A-Namespace&lt;/li&gt;
&lt;li&gt;B-Namespace&lt;/li&gt;
&lt;li&gt;A-StatefulSet&lt;/li&gt;
&lt;li&gt;B-ReplicaSet&lt;/li&gt;
&lt;li&gt;A-Service&lt;/li&gt;
&lt;li&gt;B-Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is because when Helm installs/upgrades charts,
the Kubernetes objects from the charts and all its dependencies are&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;aggregrated into a single set; then&lt;/li&gt;
&lt;li&gt;sorted by type followed by name; and then&lt;/li&gt;
&lt;li&gt;created/updated in that order.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence a single release is created with all the objects for the chart and its dependencies.&lt;/p&gt;

&lt;p&gt;The install order of Kubernetes types is given by the enumeration InstallOrder in kind_sorter.go
(see &lt;a href=&#34;https://github.com/kubernetes/helm/blob/master/pkg/tiller/kind_sorter.go#L26&#34;&gt;the Helm source file&lt;/a&gt;).&lt;/p&gt;

&lt;h2 id=&#34;templates-and-values&#34;&gt;Templates and Values&lt;/h2&gt;

&lt;p&gt;Helm Chart templates are written in the
&lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;Go template language&lt;/a&gt;, with the
addition of 50 or so add-on template
functions &lt;a href=&#34;https://github.com/Masterminds/sprig&#34;&gt;from the Sprig library&lt;/a&gt; and a
few other &lt;a href=&#34;./#chart-development-tips-and-tricks&#34;&gt;specialized functions&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All template files are stored in a chart&amp;rsquo;s &lt;code&gt;templates/&lt;/code&gt; folder. When
Helm renders the charts, it will pass every file in that directory
through the template engine.&lt;/p&gt;

&lt;p&gt;Values for the templates are supplied two ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Chart developers may supply a file called &lt;code&gt;values.yaml&lt;/code&gt; inside of a
chart. This file can contain default values.&lt;/li&gt;
&lt;li&gt;Chart users may supply a YAML file that contains values. This can be
provided on the command line with &lt;code&gt;helm install&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When a user supplies custom values, these values will override the
values in the chart&amp;rsquo;s &lt;code&gt;values.yaml&lt;/code&gt; file.&lt;/p&gt;

&lt;h3 id=&#34;template-files&#34;&gt;Template Files&lt;/h3&gt;

&lt;p&gt;Template files follow the standard conventions for writing Go templates
(see &lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;the text/template Go package documentation&lt;/a&gt;
for details).
An example template file might look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    heritage: deis
spec:
  replicas: 1
  selector:
    app: deis-database
  template:
    metadata:
      labels:
        app: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}
          imagePullPolicy: {{.Values.pullPolicy}}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{default &amp;quot;minio&amp;quot; .Values.storage}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above example, based loosely on &lt;a href=&#34;https://github.com/deis/charts&#34;&gt;https://github.com/deis/charts&lt;/a&gt;, is a template for a Kubernetes replication controller.
It can use the following four template values (usually defined in a
&lt;code&gt;values.yaml&lt;/code&gt; file):&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;imageRegistry&lt;/code&gt;: The source registry for the Docker image.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dockerTag&lt;/code&gt;: The tag for the docker image.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pullPolicy&lt;/code&gt;: The Kubernetes pull policy.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;storage&lt;/code&gt;: The storage backend, whose default is set to &lt;code&gt;&amp;quot;minio&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these values are defined by the template author. Helm does not
require or dictate parameters.&lt;/p&gt;

&lt;p&gt;To see many working charts, check out the &lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;Kubernetes Charts
project&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;predefined-values&#34;&gt;Predefined Values&lt;/h3&gt;

&lt;p&gt;Values that are supplied via a &lt;code&gt;values.yaml&lt;/code&gt; file (or via the &lt;code&gt;--set&lt;/code&gt;
flag) are accessible from the &lt;code&gt;.Values&lt;/code&gt; object in a template. But there
are other pre-defined pieces of data you can access in your templates.&lt;/p&gt;

&lt;p&gt;The following values are pre-defined, are available to every template, and
cannot be overridden. As with all values, the names are &lt;em&gt;case
sensitive&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Release.Name&lt;/code&gt;: The name of the release (not the chart)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release.Time&lt;/code&gt;: The time the chart release was last updated. This will
match the &lt;code&gt;Last Released&lt;/code&gt; time on a Release object.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release.Namespace&lt;/code&gt;: The namespace the chart was released to.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release.Service&lt;/code&gt;: The service that conducted the release. Usually
this is &lt;code&gt;Tiller&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release.IsUpgrade&lt;/code&gt;: This is set to true if the current operation is an upgrade or rollback.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release.IsInstall&lt;/code&gt;: This is set to true if the current operation is an
install.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Release.Revision&lt;/code&gt;: The revision number. It begins at 1, and increments with
each &lt;code&gt;helm upgrade&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chart&lt;/code&gt;: The contents of the &lt;code&gt;Chart.yaml&lt;/code&gt;. Thus, the chart version is
obtainable as &lt;code&gt;Chart.Version&lt;/code&gt; and the maintainers are in
&lt;code&gt;Chart.Maintainers&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Files&lt;/code&gt;: A map-like object containing all non-special files in the chart. This
will not give you access to templates, but will give you access to additional
files that are present (unless they are excluded using &lt;code&gt;.helmignore&lt;/code&gt;). Files can be
accessed using &lt;code&gt;{{index .Files &amp;quot;file.name&amp;quot;}}&lt;/code&gt; or using the &lt;code&gt;{{.Files.Get name}}&lt;/code&gt; or
&lt;code&gt;{{.Files.GetString name}}&lt;/code&gt; functions. You can also access the contents of the file
as &lt;code&gt;[]byte&lt;/code&gt; using &lt;code&gt;{{.Files.GetBytes}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Capabilities&lt;/code&gt;: A map-like object that contains information about the versions
of Kubernetes (&lt;code&gt;{{.Capabilities.KubeVersion}}&lt;/code&gt;, Tiller
(&lt;code&gt;{{.Capabilities.TillerVersion}}&lt;/code&gt;, and the supported Kubernetes API versions
(&lt;code&gt;{{.Capabilities.APIVersions.Has &amp;quot;batch/v1&amp;quot;&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Any unknown Chart.yaml fields will be dropped. They will not
be accessible inside of the &lt;code&gt;Chart&lt;/code&gt; object. Thus, Chart.yaml cannot be
used to pass arbitrarily structured data into the template. The values
file can be used for that, though.&lt;/p&gt;

&lt;h3 id=&#34;values-files&#34;&gt;Values files&lt;/h3&gt;

&lt;p&gt;Considering the template in the previous section, a &lt;code&gt;values.yaml&lt;/code&gt; file
that supplies the necessary values would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;imageRegistry: &amp;quot;quay.io/deis&amp;quot;
dockerTag: &amp;quot;latest&amp;quot;
pullPolicy: &amp;quot;Always&amp;quot;
storage: &amp;quot;s3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A values file is formatted in YAML. A chart may include a default
&lt;code&gt;values.yaml&lt;/code&gt; file. The Helm install command allows a user to override
values by supplying additional YAML values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm install --values=myvals.yaml wordpress
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When values are passed in this way, they will be merged into the default
values file. For example, consider a &lt;code&gt;myvals.yaml&lt;/code&gt; file that looks like
this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;storage: &amp;quot;gcs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When this is merged with the &lt;code&gt;values.yaml&lt;/code&gt; in the chart, the resulting
generated content will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;imageRegistry: &amp;quot;quay.io/deis&amp;quot;
dockerTag: &amp;quot;latest&amp;quot;
pullPolicy: &amp;quot;Always&amp;quot;
storage: &amp;quot;gcs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that only the last field was overridden.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The default values file included inside of a chart &lt;em&gt;must&lt;/em&gt; be named
&lt;code&gt;values.yaml&lt;/code&gt;. But files specified on the command line can be named
anything.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; If the &lt;code&gt;--set&lt;/code&gt; flag is used on &lt;code&gt;helm install&lt;/code&gt; or &lt;code&gt;helm upgrade&lt;/code&gt;, those
values are simply converted to YAML on the client side.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; If any required entries in the values file exist, they can be declared
as required in the chart template by using the &lt;a href=&#34;./#chart-development-tips-and-tricks&#34;&gt;&amp;lsquo;required&amp;rsquo; function&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Any of these values are then accessible inside of templates using the
&lt;code&gt;.Values&lt;/code&gt; object:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: v1
kind: ReplicationController
metadata:
  name: deis-database
  namespace: deis
  labels:
    heritage: deis
spec:
  replicas: 1
  selector:
    app: deis-database
  template:
    metadata:
      labels:
        app: deis-database
    spec:
      serviceAccount: deis-database
      containers:
        - name: deis-database
          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}
          imagePullPolicy: {{.Values.pullPolicy}}
          ports:
            - containerPort: 5432
          env:
            - name: DATABASE_STORAGE
              value: {{default &amp;quot;minio&amp;quot; .Values.storage}}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;scope-dependencies-and-values&#34;&gt;Scope, Dependencies, and Values&lt;/h3&gt;

&lt;p&gt;Values files can declare values for the top-level chart, as well as for
any of the charts that are included in that chart&amp;rsquo;s &lt;code&gt;charts/&lt;/code&gt; directory.
Or, to phrase it differently, a values file can supply values to the
chart as well as to any of its dependencies. For example, the
demonstration WordPress chart above has both &lt;code&gt;mysql&lt;/code&gt; and &lt;code&gt;apache&lt;/code&gt; as
dependencies. The values file could supply values to all of these
components:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;title: &amp;quot;My WordPress Site&amp;quot; # Sent to the WordPress template

mysql:
  max_connections: 100 # Sent to MySQL
  password: &amp;quot;secret&amp;quot;

apache:
  port: 8080 # Passed to Apache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Charts at a higher level have access to all of the variables defined
beneath. So the WordPress chart can access the MySQL password as
&lt;code&gt;.Values.mysql.password&lt;/code&gt;. But lower level charts cannot access things in
parent charts, so MySQL will not be able to access the &lt;code&gt;title&lt;/code&gt; property. Nor,
for that matter, can it access &lt;code&gt;apache.port&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Values are namespaced, but namespaces are pruned. So for the WordPress
chart, it can access the MySQL password field as &lt;code&gt;.Values.mysql.password&lt;/code&gt;. But
for the MySQL chart, the scope of the values has been reduced and the
namespace prefix removed, so it will see the password field simply as
&lt;code&gt;.Values.password&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;global-values&#34;&gt;Global Values&lt;/h4&gt;

&lt;p&gt;As of 2.0.0-Alpha.2, Helm supports special &amp;ldquo;global&amp;rdquo; value. Consider
this modified version of the previous example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;title: &amp;quot;My WordPress Site&amp;quot; # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  max_connections: 100 # Sent to MySQL
  password: &amp;quot;secret&amp;quot;

apache:
  port: 8080 # Passed to Apache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above adds a &lt;code&gt;global&lt;/code&gt; section with the value &lt;code&gt;app: MyWordPress&lt;/code&gt;.
This value is available to &lt;em&gt;all&lt;/em&gt; charts as &lt;code&gt;.Values.global.app&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, the &lt;code&gt;mysql&lt;/code&gt; templates may access &lt;code&gt;app&lt;/code&gt; as &lt;code&gt;{{.Values.global.app}}&lt;/code&gt;, and
so can the &lt;code&gt;apache&lt;/code&gt; chart. Effectively, the values file above is
regenerated like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;title: &amp;quot;My WordPress Site&amp;quot; # Sent to the WordPress template

global:
  app: MyWordPress

mysql:
  global:
    app: MyWordPress
  max_connections: 100 # Sent to MySQL
  password: &amp;quot;secret&amp;quot;

apache:
  global:
    app: MyWordPress
  port: 8080 # Passed to Apache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This provides a way of sharing one top-level variable with all
subcharts, which is useful for things like setting &lt;code&gt;metadata&lt;/code&gt; properties
like labels.&lt;/p&gt;

&lt;p&gt;If a subchart declares a global variable, that global will be passed
&lt;em&gt;downward&lt;/em&gt; (to the subchart&amp;rsquo;s subcharts), but not &lt;em&gt;upward&lt;/em&gt; to the parent
chart. There is no way for a subchart to influence the values of the
parent chart.&lt;/p&gt;

&lt;p&gt;Also, global variables of parent charts take precedence over the global variables from subcharts.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;p&gt;When it comes to writing templates and values files, there are several
standard references that will help you out.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/text/template&#34;&gt;Go templates&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/Masterminds/sprig&#34;&gt;Extra template functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://yaml.org/spec/&#34;&gt;The YAML format&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;using-helm-to-manage-charts&#34;&gt;Using Helm to Manage Charts&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;helm&lt;/code&gt; tool has several commands for working with charts.&lt;/p&gt;

&lt;p&gt;It can create a new chart for you:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm create mychart
Created mychart/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have edited a chart, &lt;code&gt;helm&lt;/code&gt; can package it into a chart archive
for you:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm package mychart
Archived mychart-0.1.-.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use &lt;code&gt;helm&lt;/code&gt; to help you find issues with your chart&amp;rsquo;s
formatting or information:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm lint mychart
No issues found
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;chart-repositories&#34;&gt;Chart Repositories&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;chart repository&lt;/em&gt; is an HTTP server that houses one or more packaged
charts. While &lt;code&gt;helm&lt;/code&gt; can be used to manage local chart directories, when
it comes to sharing charts, the preferred mechanism is a chart
repository.&lt;/p&gt;

&lt;p&gt;Any HTTP server that can serve YAML files and tar files and can answer
GET requests can be used as a repository server.&lt;/p&gt;

&lt;p&gt;Helm comes with built-in package server for developer testing (&lt;code&gt;helm
serve&lt;/code&gt;). The Helm team has tested other servers, including Google Cloud
Storage with website mode enabled, and S3 with website mode enabled.&lt;/p&gt;

&lt;p&gt;A repository is characterized primarily by the presence of a special
file called &lt;code&gt;index.yaml&lt;/code&gt; that has a list of all of the packages supplied
by the repository, together with metadata that allows retrieving and
verifying those packages.&lt;/p&gt;

&lt;p&gt;On the client side, repositories are managed with the &lt;code&gt;helm repo&lt;/code&gt;
commands. However, Helm does not provide tools for uploading charts to
remote repository servers. This is because doing so would add
substantial requirements to an implementing server, and thus raise the
barrier for setting up a repository.&lt;/p&gt;

&lt;h2 id=&#34;chart-starter-packs&#34;&gt;Chart Starter Packs&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;helm create&lt;/code&gt; command takes an optional &lt;code&gt;--starter&lt;/code&gt; option that lets you
specify a &amp;ldquo;starter chart&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Starters are just regular charts, but are located in &lt;code&gt;$HELM_HOME/starters&lt;/code&gt;.
As a chart developer, you may author charts that are specifically designed
to be used as starters. Such charts should be designed with the following
considerations in mind:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Chart.yaml&lt;/code&gt; will be overwritten by the generator.&lt;/li&gt;
&lt;li&gt;Users will expect to modify such a chart&amp;rsquo;s contents, so documentation
should indicate how users can do so.&lt;/li&gt;
&lt;li&gt;All occurances of &lt;code&gt;&amp;lt;CHARTNAME&amp;gt;&lt;/code&gt; will be replaced with the specified chart
name so that starter charts can be used as templates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Currently the only way to add a chart to &lt;code&gt;$HELM_HOME/starters&lt;/code&gt; is to manually
copy it there. In your chart&amp;rsquo;s documentation, you may want to explain that
process.&lt;/p&gt;

&lt;h1 id=&#34;hooks&#34;&gt;Hooks&lt;/h1&gt;

&lt;p&gt;Helm provides a &lt;em&gt;hook&lt;/em&gt; mechanism to allow chart developers to intervene
at certain points in a release&amp;rsquo;s life cycle. For example, you can use
hooks to:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Load a ConfigMap or Secret during install before any other charts are
loaded.&lt;/li&gt;
&lt;li&gt;Execute a Job to back up a database before installing a new chart,
and then execute a second job after the upgrade in order to restore
data.&lt;/li&gt;
&lt;li&gt;Run a Job before deleting a release to gracefully take a service out
of rotation before removing it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hooks work like regular templates, but they have special annotations
that cause Helm to utilize them differently. In this section, we cover
the basic usage pattern for hooks.&lt;/p&gt;

&lt;h2 id=&#34;the-available-hooks&#34;&gt;The Available Hooks&lt;/h2&gt;

&lt;p&gt;The following hooks are defined:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pre-install: Executes after templates are rendered, but before any
resources are created in Kubernetes.&lt;/li&gt;
&lt;li&gt;post-install: Executes after all resources are loaded into Kubernetes&lt;/li&gt;
&lt;li&gt;pre-delete: Executes on a deletion request before any resources are
deleted from Kubernetes.&lt;/li&gt;
&lt;li&gt;post-delete: Executes on a deletion request after all of the release&amp;rsquo;s
resources have been deleted.&lt;/li&gt;
&lt;li&gt;pre-upgrade: Executes on an upgrade request after templates are
rendered, but before any resources are loaded into Kubernetes (e.g.
before a Kubernetes apply operation).&lt;/li&gt;
&lt;li&gt;post-upgrade: Executes on an upgrade after all resources have been
upgraded.&lt;/li&gt;
&lt;li&gt;pre-rollback: Executes on a rollback request after templates are
rendered, but before any resources have been rolled back.&lt;/li&gt;
&lt;li&gt;post-rollback: Executes on a rollback request after all resources
have been modified.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hooks-and-the-release-lifecycle&#34;&gt;Hooks and the Release Lifecycle&lt;/h2&gt;

&lt;p&gt;Hooks allow you, the chart developer, an opportunity to perform
operations at strategic points in a release lifecycle. For example,
consider the lifecycle for a &lt;code&gt;helm install&lt;/code&gt;. By default, the lifecycle
looks like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;User runs &lt;code&gt;helm install foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Chart is loaded into Tiller&lt;/li&gt;
&lt;li&gt;After some verification, Tiller renders the &lt;code&gt;foo&lt;/code&gt; templates&lt;/li&gt;
&lt;li&gt;Tiller loads the resulting resources into Kubernetes&lt;/li&gt;
&lt;li&gt;Tiller returns the release name (and other data) to the client&lt;/li&gt;
&lt;li&gt;The client exits&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Helm defines two hooks for the &lt;code&gt;install&lt;/code&gt; lifecycle: &lt;code&gt;pre-install&lt;/code&gt; and
&lt;code&gt;post-install&lt;/code&gt;. If the developer of the &lt;code&gt;foo&lt;/code&gt; chart implements both
hooks, the lifecycle is altered like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;User runs &lt;code&gt;helm install foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Chart is loaded into Tiller&lt;/li&gt;
&lt;li&gt;After some verification, Tiller renders the &lt;code&gt;foo&lt;/code&gt; templates&lt;/li&gt;
&lt;li&gt;Tiller prepares to execute the &lt;code&gt;pre-install&lt;/code&gt; hooks (loading hook resources into
Kubernetes)&lt;/li&gt;
&lt;li&gt;Tiller sorts hooks by weight (assigning a weight of 0 by default) and by name for those hooks with the same weight in ascending order.&lt;/li&gt;
&lt;li&gt;Tiller then loads the hook with the lowest weight first (negative to positive)&lt;/li&gt;
&lt;li&gt;Tiller waits until the hook is &amp;ldquo;Ready&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Tiller loads the resulting resources into Kubernetes. Note that if the &lt;code&gt;--wait&lt;/code&gt;
flag is set, Tiller will wait until all resources are in a ready state
and will not run the &lt;code&gt;post-install&lt;/code&gt; hook until they are ready.&lt;/li&gt;
&lt;li&gt;Tiller executes the &lt;code&gt;post-install&lt;/code&gt; hook (loading hook resources)&lt;/li&gt;
&lt;li&gt;Tiller waits until the hook is &amp;ldquo;Ready&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Tiller returns the release name (and other data) to the client&lt;/li&gt;
&lt;li&gt;The client exits&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What does it mean to wait until a hook is ready? This depends on the
resource declared in the hook. If the resources is a &lt;code&gt;Job&lt;/code&gt; kind, Tiller
will wait until the job successfully runs to completion. And if the job
fails, the release will fail. This is a &lt;em&gt;blocking operation&lt;/em&gt;, so the
Helm client will pause while the Job is run.&lt;/p&gt;

&lt;p&gt;For all other kinds, as soon as Kubernetes marks the resource as loaded
(added or updated), the resource is considered &amp;ldquo;Ready&amp;rdquo;. When many
resources are declared in a hook, the resources are executed serially. If they
have hook weights (see below), they are executed in weighted order. Otherwise,
ordering is not guaranteed. (In Helm 2.3.0 and after, they are sorted
alphabetically. That behavior, though, is not considered binding and could change
in the future.) It is considered good practice to add a hook weight, and set it
to &lt;code&gt;0&lt;/code&gt; if weight is not important.&lt;/p&gt;

&lt;h3 id=&#34;hook-resources-are-not-managed-with-corresponding-releases&#34;&gt;Hook resources are not managed with corresponding releases&lt;/h3&gt;

&lt;p&gt;The resources that a hook creates are not tracked or managed as part of the
release. Once Tiller verifies that the hook has reached its ready state, it
will leave the hook resource alone.&lt;/p&gt;

&lt;p&gt;Practically speaking, this means that if you create resources in a hook, you
cannot rely upon &lt;code&gt;helm delete&lt;/code&gt; to remove the resources. To destroy such
resources, you need to either write code to perform this operation in a &lt;code&gt;pre-delete&lt;/code&gt;
or &lt;code&gt;post-delete&lt;/code&gt; hook or add &lt;code&gt;&amp;quot;helm.sh/hook-delete-policy&amp;quot;&lt;/code&gt; annotation to the hook template file.&lt;/p&gt;

&lt;h2 id=&#34;writing-a-hook&#34;&gt;Writing a Hook&lt;/h2&gt;

&lt;p&gt;Hooks are just Kubernetes manifest files with special annotations in the
&lt;code&gt;metadata&lt;/code&gt; section. Because they are template files, you can use all of
the normal template features, including reading &lt;code&gt;.Values&lt;/code&gt;, &lt;code&gt;.Release&lt;/code&gt;,
and &lt;code&gt;.Template&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For example, this template, stored in &lt;code&gt;templates/post-install-job.yaml&lt;/code&gt;,
declares a job to be run on &lt;code&gt;post-install&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;apiVersion: batch/v1
kind: Job
metadata:
  name: &amp;quot;{{.Release.Name}}&amp;quot;
  labels:
    heritage: {{.Release.Service | quote }}
    release: {{.Release.Name | quote }}
    chart: &amp;quot;{{.Chart.Name}}-{{.Chart.Version}}&amp;quot;
  annotations:
    # This is what defines this resource as a hook. Without this line, the
    # job is considered part of the release.
    &amp;quot;helm.sh/hook&amp;quot;: post-install
    &amp;quot;helm.sh/hook-weight&amp;quot;: &amp;quot;-5&amp;quot;
    &amp;quot;helm.sh/hook-delete-policy&amp;quot;: hook-succeeded
spec:
  template:
    metadata:
      name: &amp;quot;{{.Release.Name}}&amp;quot;
      labels:
        heritage: {{.Release.Service | quote }}
        release: {{.Release.Name | quote }}
        chart: &amp;quot;{{.Chart.Name}}-{{.Chart.Version}}&amp;quot;
    spec:
      restartPolicy: Never
      containers:
      - name: post-install-job
        image: &amp;quot;alpine:3.3&amp;quot;
        command: [&amp;quot;/bin/sleep&amp;quot;,&amp;quot;{{default &amp;quot;10&amp;quot; .Values.sleepyTime}}&amp;quot;]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What makes this template a hook is the annotation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  annotations:
    &amp;quot;helm.sh/hook&amp;quot;: post-install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One resource can implement multiple hooks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  annotations:
    &amp;quot;helm.sh/hook&amp;quot;: post-install,post-upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, there is no limit to the number of different resources that
may implement a given hook. For example, one could declare both a secret
and a config map as a pre-install hook.&lt;/p&gt;

&lt;p&gt;When subcharts declare hooks, those are also evaluated. There is no way
for a top-level chart to disable the hooks declared by subcharts.&lt;/p&gt;

&lt;p&gt;It is possible to define a weight for a hook which will help build a
deterministic executing order. Weights are defined using the following annotation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  annotations:
    &amp;quot;helm.sh/hook-weight&amp;quot;: &amp;quot;5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hook weights can be positive or negative numbers but must be represented as
strings. When Tiller starts the execution cycle of hooks of a particular Kind it
will sort those hooks in ascending order.&lt;/p&gt;

&lt;p&gt;It is also possible to define policies that determine when to delete corresponding hook resources. Hook deletion policies are defined using the following annotation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  annotations:
    &amp;quot;helm.sh/hook-delete-policy&amp;quot;: hook-succeeded
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using &lt;code&gt;&amp;quot;helm.sh/hook-delete-policy&amp;quot;&lt;/code&gt; annotation, you can choose its value from &lt;code&gt;&amp;quot;hook-succeeded&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;hook-failed&amp;quot;&lt;/code&gt;. The value &lt;code&gt;&amp;quot;hook-succeeded&amp;quot;&lt;/code&gt; specifies Tiller should delete the hook after the hook is successfully executed, while the value &lt;code&gt;&amp;quot;hook-failed&amp;quot;&lt;/code&gt;specifies Tiller should delete the hook if the hook failed during execution.&lt;/p&gt;

&lt;h1 id=&#34;chart-development-tips-and-tricks&#34;&gt;Chart Development Tips and Tricks&lt;/h1&gt;

&lt;p&gt;This guide covers some of the tips and tricks Helm chart developers have
learned while building production-quality charts.&lt;/p&gt;

&lt;h2 id=&#34;know-your-template-functions&#34;&gt;Know Your Template Functions&lt;/h2&gt;

&lt;p&gt;Helm uses &lt;a href=&#34;https://godoc.org/text/template&#34;&gt;Go templates&lt;/a&gt; for templating
your resource files. While Go ships several built-in functions, we have
added many others.&lt;/p&gt;

&lt;p&gt;First, we added almost all of the functions in the
&lt;a href=&#34;https://godoc.org/github.com/Masterminds/sprig&#34;&gt;Sprig library&lt;/a&gt;. We removed two
for security reasons: &lt;code&gt;env&lt;/code&gt; and &lt;code&gt;expandenv&lt;/code&gt; (which would have given chart authors
access to Tiller&amp;rsquo;s environment).&lt;/p&gt;

&lt;p&gt;We also added two special template functions: &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;required&lt;/code&gt;. The &lt;code&gt;include&lt;/code&gt;
function allows you to bring in another template, and then pass the results to other
template functions.&lt;/p&gt;

&lt;p&gt;For example, this template snippet includes a template called &lt;code&gt;mytpl&lt;/code&gt;, then
lowercases the result, then wraps that in double quotes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;value: {{include &amp;quot;mytpl&amp;quot; . | lower | quote}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;required&lt;/code&gt; function allows you to declare a particular
values entry as required for template rendering.  If the value is empty, the template
rendering will fail with a user submitted error message.&lt;/p&gt;

&lt;p&gt;The following example of the &lt;code&gt;required&lt;/code&gt; function declares an entry for .Values.who
is required, and will print an error message when that entry is missing:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;value: {{required &amp;quot;A valid .Values.who entry required!&amp;quot; .Values.who }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;quote-strings-don-t-quote-integers&#34;&gt;Quote Strings, Don&amp;rsquo;t Quote Integers&lt;/h2&gt;

&lt;p&gt;When you are working with string data, you are always safer quoting the
strings than leaving them as bare words:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name: {{.Values.MyName | quote }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when working with integers &lt;em&gt;do not quote the values.&lt;/em&gt; That can, in
many cases, cause parsing errors inside of Kubernetes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;port: {{ .Values.Port }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This remark does not apply to env variables values which are expected to be string, even if they represent integers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;env:
  -name: HOST
    value: &amp;quot;http://host&amp;quot;
  -name: PORT
    value: &amp;quot;1234&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;using-the-include-function&#34;&gt;Using the &amp;lsquo;include&amp;rsquo; Function&lt;/h2&gt;

&lt;p&gt;Go provides a way of including one template in another using a built-in
&lt;code&gt;template&lt;/code&gt; directive. However, the built-in function cannot be used in
Go template pipelines.&lt;/p&gt;

&lt;p&gt;To make it possible to include a template, and then perform an operation
on that template&amp;rsquo;s output, Helm has a special &lt;code&gt;include&lt;/code&gt; function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ include &amp;quot;toYaml&amp;quot; $value | indent 2 }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above includes a template called &lt;code&gt;toYaml&lt;/code&gt;, passes it &lt;code&gt;$value&lt;/code&gt;, and
then passes the output of that template to the &lt;code&gt;indent&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Because YAML ascribes significance to indentation levels and whitespace,
this is one great way to include snippets of code, but handle
indentation in a relevant context.&lt;/p&gt;

&lt;h2 id=&#34;using-the-required-function&#34;&gt;Using the &amp;lsquo;required&amp;rsquo; function&lt;/h2&gt;

&lt;p&gt;Go provides a way for setting template options to control behavior
when a map is indexed with a key that&amp;rsquo;s not present in the map. This
is typically set with template.Options(&amp;ldquo;missingkey=option&amp;rdquo;), where option
can be default, zero, or error. While setting this option to error will
stop execution with an error, this would apply to every missing key in the
map. There may be situations where a chart developer wants to enforce this
behavior for select values in the values.yml file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;required&lt;/code&gt; function gives developers the ability to declare a value entry
as required for template rendering. If the entry is empty in values.yml, the
template will not render and will return an error message supplied by the
developer.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ required &amp;quot;A valid foo is required!&amp;quot; .Values.foo }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above will render the template when .Values.foo is defined, but will fail
to render and exit when .Values.foo is undefined.&lt;/p&gt;

&lt;h2 id=&#34;creating-image-pull-secrets&#34;&gt;Creating Image Pull Secrets&lt;/h2&gt;

&lt;p&gt;Image pull secrets are essentially a combination of &lt;em&gt;registry&lt;/em&gt;, &lt;em&gt;username&lt;/em&gt;, and &lt;em&gt;password&lt;/em&gt;.  You may need them in an application you are deploying, but to create them requires running &lt;em&gt;base64&lt;/em&gt; a couple of times.  We can write a helper template to compose the Docker configuration file for use as the Secret&amp;rsquo;s payload.  Here is an example:&lt;/p&gt;

&lt;p&gt;First, assume that the credentials are defined in the &lt;code&gt;values.yaml&lt;/code&gt; file like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;imageCredentials:
  registry: quay.io
  username: someone
  password: sillyness
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We then define our helper template as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{- define &amp;quot;imagePullSecret&amp;quot; }}
{{- printf &amp;quot;{\&amp;quot;auths\&amp;quot;: {\&amp;quot;%s\&amp;quot;: {\&amp;quot;auth\&amp;quot;: \&amp;quot;%s\&amp;quot;}}}&amp;quot; .Values.imageCredentials.registry (printf &amp;quot;%s:%s&amp;quot; .Values.imageCredentials.username .Values.imageCredentials.password | b64enc) | b64enc }}
{{- end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we use the helper template in a larger template to create the Secret manifest:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: {{ template &amp;quot;imagePullSecret&amp;quot; . }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;automatically-roll-deployments-when-configmaps-or-secrets-change&#34;&gt;Automatically Roll Deployments When ConfigMaps or Secrets change&lt;/h2&gt;

&lt;p&gt;Often times configmaps or secrets are injected as configuration
files in containers.
Depending on the application a restart may be required should those
be updated with a subsequent &lt;code&gt;helm upgrade&lt;/code&gt;, but if the
deployment spec itself didn&amp;rsquo;t change the application keeps running
with the old configuration resulting in an inconsistent deployment.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;sha256sum&lt;/code&gt; function can be used to ensure a deployment&amp;rsquo;s
annotation section is updated if another file changes:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: Deployment
spec:
  template:
    metadata:
      annotations:
        checksum/config: {{ include (print $.Template.BasePath &amp;quot;/configmap.yaml&amp;quot;) . | sha256sum }}
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See also the &lt;code&gt;helm upgrade --recreate-pods&lt;/code&gt; flag for a slightly
different way of addressing this issue.&lt;/p&gt;

&lt;h2 id=&#34;tell-tiller-not-to-delete-a-resource&#34;&gt;Tell Tiller Not To Delete a Resource&lt;/h2&gt;

&lt;p&gt;Sometimes there are resources that should not be deleted when Helm runs a
&lt;code&gt;helm delete&lt;/code&gt;. Chart developers can add an annotation to a resource to prevent
it from being deleted.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;kind: Secret
metadata:
  annotations:
    &amp;quot;helm.sh/resource-policy&amp;quot;: keep
[...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Quotation marks are required)&lt;/p&gt;

&lt;p&gt;The annotation &lt;code&gt;&amp;quot;helm.sh/resource-policy&amp;quot;: keep&lt;/code&gt; instructs Tiller to skip this
resource during a &lt;code&gt;helm delete&lt;/code&gt; operation. &lt;em&gt;However&lt;/em&gt;, this resource becomes
orphaned. Helm will no longer manage it in any way. This can lead to problems
if using &lt;code&gt;helm install --replace&lt;/code&gt; on a release that has already been deleted, but
has kept resources.&lt;/p&gt;

&lt;h2 id=&#34;using-partials-and-template-includes&#34;&gt;Using &amp;ldquo;Partials&amp;rdquo; and Template Includes&lt;/h2&gt;

&lt;p&gt;Sometimes you want to create some reusable parts in your chart, whether
they&amp;rsquo;re blocks or template partials. And often, it&amp;rsquo;s cleaner to keep
these in their own files.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;templates/&lt;/code&gt; directory, any file that begins with an
underscore(&lt;code&gt;_&lt;/code&gt;) is not expected to output a Kubernetes manifest file. So
by convention, helper templates and partials are placed in a
&lt;code&gt;_helpers.tpl&lt;/code&gt; file.&lt;/p&gt;

&lt;h2 id=&#34;complex-charts-with-many-dependencies&#34;&gt;Complex Charts with Many Dependencies&lt;/h2&gt;

&lt;p&gt;Many of the charts in the &lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;official charts repository&lt;/a&gt;
are &amp;ldquo;building blocks&amp;rdquo; for creating more advanced applications. But charts may be
used to create instances of large-scale applications. In such cases, a single
umbrella chart may have multiple subcharts, each of which functions as a piece
of the whole.&lt;/p&gt;

&lt;p&gt;The current best practice for composing a complex application from discrete parts
is to create a top-level umbrella chart that
exposes the global configurations, and then use the &lt;code&gt;charts/&lt;/code&gt; subdirectory to
embed each of the components.&lt;/p&gt;

&lt;p&gt;Two strong design patterns are illustrated by these projects:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SAP&amp;rsquo;s &lt;a href=&#34;https://github.com/sapcc/openstack-helm&#34;&gt;OpenStack chart&lt;/a&gt;:&lt;/strong&gt; This chart
installs a full OpenStack IaaS on Kubernetes. All of the charts are collected
together in one GitHub repository.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Deis&amp;rsquo;s &lt;a href=&#34;https://github.com/deis/workflow/tree/master/charts/workflow&#34;&gt;Workflow&lt;/a&gt;:&lt;/strong&gt;
This chart exposes the entire Deis PaaS system with one chart. But it&amp;rsquo;s different
from the SAP chart in that this umbrella chart is built from each component, and
each component is tracked in a different Git repository. Check out the
&lt;code&gt;requirements.yaml&lt;/code&gt; file to see how this chart is composed by their CI/CD
pipeline.&lt;/p&gt;

&lt;p&gt;Both of these charts illustrate proven techniques for standing up complex environments
using Helm.&lt;/p&gt;

&lt;h2 id=&#34;yaml-is-a-superset-of-json&#34;&gt;YAML is a Superset of JSON&lt;/h2&gt;

&lt;p&gt;According to the YAML specification, YAML is a superset of JSON. That
means that any valid JSON structure ought to be valid in YAML.&lt;/p&gt;

&lt;p&gt;This has an advantage: Sometimes template developers may find it easier
to express a datastructure with a JSON-like syntax rather than deal with
YAML&amp;rsquo;s whitespace sensitivity.&lt;/p&gt;

&lt;p&gt;As a best practice, templates should follow a YAML-like syntax &lt;em&gt;unless&lt;/em&gt;
the JSON syntax substantially reduces the risk of a formatting issue.&lt;/p&gt;

&lt;h2 id=&#34;be-careful-with-generating-random-values&#34;&gt;Be Careful with Generating Random Values&lt;/h2&gt;

&lt;p&gt;There are functions in Helm that allow you to generate random data,
cryptographic keys, and so on. These are fine to use. But be aware that
during upgrades, templates are re-executed. When a template run
generates data that differs from the last run, that will trigger an
update of that resource.&lt;/p&gt;

&lt;h2 id=&#34;upgrade-a-release-idempotently&#34;&gt;Upgrade a release idempotently&lt;/h2&gt;

&lt;p&gt;In order to use the same command when installing and upgrading a release, use the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;helm upgrade --install &amp;lt;release name&amp;gt; --values &amp;lt;values file&amp;gt; &amp;lt;chart directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;the-chart-repository-guide&#34;&gt;The Chart Repository Guide&lt;/h1&gt;

&lt;p&gt;This section explains how to create and work with Helm chart repositories. At a
high level, a chart repository is a location where packaged charts can be
stored and shared.&lt;/p&gt;

&lt;p&gt;The official chart repository is maintained by the
&lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;Kubernetes Charts&lt;/a&gt;, and we welcome
participation. But Helm also makes it easy to create and run your own chart
repository. This guide explains how to do so.&lt;/p&gt;

&lt;h2 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go through the &lt;a href=&#34;./#quickstart&#34;&gt;Quickstart&lt;/a&gt; Guide&lt;/li&gt;
&lt;li&gt;Read through the &lt;a href=&#34;./#charts&#34;&gt;Charts&lt;/a&gt; document&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;create-a-chart-repository&#34;&gt;Create a chart repository&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;chart repository&lt;/em&gt; is an HTTP server that houses an &lt;code&gt;index.yaml&lt;/code&gt; file and
optionally some packaged charts.  When you&amp;rsquo;re ready to share your charts, the
preferred way to do so is by uploading them to a chart repository.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; For Helm 2.0.0, chart repositories do not have any intrinsic
authentication. There is an &lt;a href=&#34;https://github.com/kubernetes/helm/issues/1038&#34;&gt;issue tracking progress&lt;/a&gt;
in GitHub.&lt;/p&gt;

&lt;p&gt;Because a chart repository can be any HTTP server that can serve YAML and tar
files and can answer GET requests, you have a plethora of options when it comes
down to hosting your own chart repository. For example, you can use a Google
Cloud Storage (GCS) bucket, Amazon S3 bucket, Github Pages, or even create your
own web server.&lt;/p&gt;

&lt;h3 id=&#34;the-chart-repository-structure&#34;&gt;The chart repository structure&lt;/h3&gt;

&lt;p&gt;A chart repository consists of packaged charts and a special file called
&lt;code&gt;index.yaml&lt;/code&gt; which contains an index of all of the charts in the repository.
Frequently, the charts that &lt;code&gt;index.yaml&lt;/code&gt; describes are also hosted on the same
server, as are the &lt;a href=&#34;./#helm-provenance-and-integrity&#34;&gt;provenance files&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;For example, the layout of the repository &lt;code&gt;https://example.com/charts&lt;/code&gt; might
look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;charts/
  |
  |- index.yaml
  |
  |- alpine-0.1.2.tgz
  |
  |- alpine-0.1.2.tgz.prov
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the index file would contain information about one chart, the Alpine
chart, and provide the download URL &lt;code&gt;https://example.com/charts/alpine-0.1.2.tgz&lt;/code&gt;
for that chart.&lt;/p&gt;

&lt;p&gt;It is not required that a chart package be located on the same server as the
&lt;code&gt;index.yaml&lt;/code&gt; file. However, doing so is often the easiest.&lt;/p&gt;

&lt;h3 id=&#34;the-index-file&#34;&gt;The index file&lt;/h3&gt;

&lt;p&gt;The index file is a yaml file called &lt;code&gt;index.yaml&lt;/code&gt;. It
contains some metadata about the package, including the contents of a
chart&amp;rsquo;s &lt;code&gt;Chart.yaml&lt;/code&gt; file. A valid chart repository must have an index file. The
index file contains information about each chart in the chart repository. The
&lt;code&gt;helm repo index&lt;/code&gt; command will generate an index file based on a given local
directory that contains packaged charts.&lt;/p&gt;

&lt;p&gt;This is an example of an index file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
entries:
  alpine:
    - created: 2016-10-06T16:23:20.499814565-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 99c76e403d752c84ead610644d4b1c2f2b453a74b921f422b9dcb8a7c8b559cd
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/kubernetes/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.2.0.tgz
      version: 0.2.0
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Deploy a basic Alpine Linux pod
      digest: 515c58e5f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cd78727
      home: https://k8s.io/helm
      name: alpine
      sources:
      - https://github.com/kubernetes/helm
      urls:
      - https://technosophos.github.io/tscharts/alpine-0.1.0.tgz
      version: 0.1.0
  nginx:
    - created: 2016-10-06T16:23:20.499543808-06:00
      description: Create a basic nginx HTTP server
      digest: aaff4545f79d8b2913a10cb400ebb6fa9c77fe813287afbacf1a0b897cdffffff
      home: https://k8s.io/helm
      name: nginx
      sources:
      - https://github.com/kubernetes/charts
      urls:
      - https://technosophos.github.io/tscharts/nginx-1.1.0.tgz
      version: 1.1.0
generated: 2016-10-06T16:23:20.499029981-06:00
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A generated index and packages can be served from a basic webserver. You can test
things out locally with the &lt;code&gt;helm serve&lt;/code&gt; command, which starts a local server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm serve --repo-path ./charts
Regenerating index. This may take a moment.
Now serving you on 127.0.0.1:8879
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above starts a local webserver, serving the charts it finds in &lt;code&gt;./charts&lt;/code&gt;. The
serve command will automatically generate an &lt;code&gt;index.yaml&lt;/code&gt; file for you during
startup.&lt;/p&gt;

&lt;h2 id=&#34;hosting-chart-repositories&#34;&gt;Hosting Chart Repositories&lt;/h2&gt;

&lt;p&gt;This part shows several ways to serve a chart repository.&lt;/p&gt;

&lt;h3 id=&#34;google-cloud-storage&#34;&gt;Google Cloud Storage&lt;/h3&gt;

&lt;p&gt;The first step is to &lt;strong&gt;create your GCS bucket&lt;/strong&gt;. We&amp;rsquo;ll call ours
&lt;code&gt;fantastic-charts&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/create-a-bucket.png&#34; alt=&#34;Create a GCS Bucket&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, make your bucket public by &lt;strong&gt;editing the bucket permissions&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/edit-permissions.png&#34; alt=&#34;Edit Permissions&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Insert this line item to &lt;strong&gt;make your bucket public&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/make-bucket-public.png&#34; alt=&#34;Make Bucket Public&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Congratulations, now you have an empty GCS bucket ready to serve charts!&lt;/p&gt;

&lt;p&gt;You may upload your chart repository using the Google Cloud Storage command line
tool, or using the GCS web UI. This is the technique the official Kubernetes
Charts repository hosts its charts, so you may want to take a
&lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;peek at that project&lt;/a&gt; if you get stuck.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; A public GCS bucket can be accessed via simple HTTPS at this address
&lt;code&gt;https://bucket-name.storage.googleapis.com/&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;github-pages-example&#34;&gt;Github Pages example&lt;/h3&gt;

&lt;p&gt;In a similar way you can create charts repository using GitHub Pages.&lt;/p&gt;

&lt;p&gt;GitHub allows you to serve static web pages in two different ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;By configuring a project to serve the contents of its &lt;code&gt;docs/&lt;/code&gt; directory&lt;/li&gt;
&lt;li&gt;By configuring a project to serve a particular branch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll take the second approach, though the first is just as easy.&lt;/p&gt;

&lt;p&gt;The first step will be to &lt;strong&gt;create your gh-pages branch&lt;/strong&gt;.  You can do that
locally as.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ git checkout -b gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or via web browser using &lt;strong&gt;Branch&lt;/strong&gt; button on your Github repository:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/create-a-gh-page-button.png&#34; alt=&#34;Create Github Pages branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next, you&amp;rsquo;ll want to make sure your &lt;strong&gt;gh-pages branch&lt;/strong&gt; is set as Github Pages,
click on your repo &lt;strong&gt;Settings&lt;/strong&gt; and scroll down to &lt;strong&gt;Github pages&lt;/strong&gt; section and
set as per below:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/kubernetes/helm/master/docs/images/set-a-gh-page.png&#34; alt=&#34;Create Github Pages branch&#34; /&gt;&lt;/p&gt;

&lt;p&gt;By default &lt;strong&gt;Source&lt;/strong&gt; usually gets set to &lt;strong&gt;gh-pages branch&lt;/strong&gt;. If this is not set by default, then select it.&lt;/p&gt;

&lt;p&gt;You can use a &lt;strong&gt;custom domain&lt;/strong&gt; there if you wish so.&lt;/p&gt;

&lt;p&gt;And check that &lt;strong&gt;Enforce HTTPS&lt;/strong&gt; is ticked, so the &lt;strong&gt;HTTPS&lt;/strong&gt; will be used when
charts are served.&lt;/p&gt;

&lt;p&gt;In such setup you can use &lt;strong&gt;master branch&lt;/strong&gt; to store your charts code, and
&lt;strong&gt;gh-pages branch&lt;/strong&gt; as charts repository, e.g.:
&lt;code&gt;https://USERNAME.github.io/REPONAME&lt;/code&gt;. The demonstration &lt;a href=&#34;https://github.com/technosophos/tscharts&#34;&gt;TS Charts&lt;/a&gt;
repository is accessible at &lt;code&gt;https://technosophos.github.io/tscharts/&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;ordinary-web-servers&#34;&gt;Ordinary web servers&lt;/h3&gt;

&lt;p&gt;To configure an ordinary web server to serve Helm charts, you merely need to do
the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Put your index and charts in a directory that the server can serve&lt;/li&gt;
&lt;li&gt;Make sure the &lt;code&gt;index.yaml&lt;/code&gt; file can be accessed with no authentication requirement&lt;/li&gt;
&lt;li&gt;Make sure &lt;code&gt;yaml&lt;/code&gt; files are served with the correct content type (&lt;code&gt;text/yaml&lt;/code&gt; or
&lt;code&gt;text/x-yaml&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, if you want to serve your charts out of &lt;code&gt;$WEBROOT/charts&lt;/code&gt;, make sure
there is a &lt;code&gt;charts/&lt;/code&gt; directory in your web root, and put the index file and
charts inside of that folder.&lt;/p&gt;

&lt;h2 id=&#34;managing-chart-repositories&#34;&gt;Managing Chart Repositories&lt;/h2&gt;

&lt;p&gt;Now that you have a chart repository, the last part of this guide explains how
to maintain charts in that repository.&lt;/p&gt;

&lt;h3 id=&#34;store-charts-in-your-chart-repository&#34;&gt;Store charts in your chart repository&lt;/h3&gt;

&lt;p&gt;Now that you have a chart repository, let&amp;rsquo;s upload a chart and an index file to
the repository.  Charts in a chart repository must be packaged
(&lt;code&gt;helm package chart-name/&lt;/code&gt;) and versioned correctly (following
&lt;a href=&#34;https://semver.org/&#34;&gt;SemVer 2&lt;/a&gt; guidelines).&lt;/p&gt;

&lt;p&gt;These next steps compose an example workflow, but you are welcome to use
whatever workflow you fancy for storing and updating charts in your chart
repository.&lt;/p&gt;

&lt;p&gt;Once you have a packaged chart ready, create a new directory, and move your
packaged chart to that directory.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm package docs/examples/alpine/
$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
$ helm repo index fantastic-charts --url https://fantastic-charts.storage.googleapis.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last command takes the path of the local directory that you just created and
the URL of your remote chart repository and composes an &lt;code&gt;index.yaml&lt;/code&gt; file inside the
given directory path.&lt;/p&gt;

&lt;p&gt;Now you can upload the chart and the index file to your chart repository using
a sync tool or manually. If you&amp;rsquo;re using Google Cloud Storage, check out this
&lt;a href=&#34;./#developing_charts_sync_example&#34;&gt;example workflow&lt;/a&gt; using the gsutil client. For
GitHub, you can simply put the charts in the appropriate destination branch.&lt;/p&gt;

&lt;h3 id=&#34;add-new-charts-to-an-existing-repository&#34;&gt;Add new charts to an existing repository&lt;/h3&gt;

&lt;p&gt;Each time you want to add a new chart to your repository, you must regenerate
the index. The &lt;code&gt;helm repo index&lt;/code&gt; command will completely rebuild the &lt;code&gt;index.yaml&lt;/code&gt;
file from scratch, including only the charts that it finds locally.&lt;/p&gt;

&lt;p&gt;However, you can use the &lt;code&gt;--merge&lt;/code&gt; flag to incrementally add new charts to an
existing &lt;code&gt;index.yaml&lt;/code&gt; file (a great option when working with a remote repository
like GCS). Run &lt;code&gt;helm repo index --help&lt;/code&gt; to learn more,&lt;/p&gt;

&lt;p&gt;Make sure that you upload both the revised &lt;code&gt;index.yaml&lt;/code&gt; file and the chart. And
if you generated a provenance file, upload that too.&lt;/p&gt;

&lt;h3 id=&#34;share-your-charts-with-others&#34;&gt;Share your charts with others&lt;/h3&gt;

&lt;p&gt;When you&amp;rsquo;re ready to share your charts, simply let someone know what the URL of
your repository is.&lt;/p&gt;

&lt;p&gt;From there, they will add the repository to their helm client via the &lt;code&gt;helm
repo add [NAME] [URL]&lt;/code&gt; command with any name they would like to use to
reference the repository.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo add fantastic-charts https://fantastic-charts.storage.googleapis.com
$ helm repo list
fantastic-charts    https://fantastic-charts.storage.googleapis.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the charts are backed by HTTP basic authentication, you can also supply the
username and password here:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo add fantastic-charts https://username:password@fantastic-charts.storage.googleapis.com
$ helm repo list
fantastic-charts    https://username:password@fantastic-charts.storage.googleapis.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; A repository will not be added if it does not contain a valid
&lt;code&gt;index.yaml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;After that, your users will be able to search through your charts. After you&amp;rsquo;ve updated
the repository, they can use the &lt;code&gt;helm repo update&lt;/code&gt; command to get the latest
chart information.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Under the hood, the &lt;code&gt;helm repo add&lt;/code&gt; and &lt;code&gt;helm repo update&lt;/code&gt; commands are
fetching the index.yaml file and storing them in the
&lt;code&gt;$HELM_HOME/repository/cache/&lt;/code&gt; directory. This is where the &lt;code&gt;helm search&lt;/code&gt;
function finds information about charts.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;syncing-your-chart-repository&#34;&gt;Syncing Your Chart Repository&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;Note: This example is specifically for a Google Cloud Storage (GCS) bucket which serves a chart repository.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;prerequisites-1&#34;&gt;Prerequisites&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Install the &lt;a href=&#34;https://cloud.google.com/storage/docs/gsutil&#34;&gt;gsutil&lt;/a&gt; tool. &lt;em&gt;We rely heavily on the gsutil rsync functionality&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Be sure to have access to the helm binary&lt;/li&gt;
&lt;li&gt;_Optional: We recommend you set &lt;a href=&#34;https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#top_of_page&#34;&gt;object versioning&lt;/a&gt; on your GCS bucket in case you accidentally delete something._&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;set-up-a-local-chart-repository-directory&#34;&gt;Set up a local chart repository directory&lt;/h2&gt;

&lt;p&gt;Create a local directory like we did in &lt;a href=&#34;./#developing_charts&#34;&gt;the chart repository guide&lt;/a&gt;, and place your packaged charts in that directory.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ mkdir fantastic-charts
$ mv alpine-0.1.0.tgz fantastic-charts/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-an-updated-index-yaml&#34;&gt;Generate an updated index.yaml&lt;/h2&gt;

&lt;p&gt;Use helm to generate an updated index.yaml file by passing in the directory path and the url of the remote repository to the &lt;code&gt;helm repo index&lt;/code&gt; command like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ helm repo index fantastic-charts/ --url https://fantastic-charts.storage.googleapis.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will generate an updated index.yaml file and place in the &lt;code&gt;fantastic-charts/&lt;/code&gt; directory.&lt;/p&gt;

&lt;h2 id=&#34;sync-your-local-and-remote-chart-repositories&#34;&gt;Sync your local and remote chart repositories&lt;/h2&gt;

&lt;p&gt;Upload the contents of the directory to your GCS bucket by running &lt;code&gt;scripts/sync-repo.sh&lt;/code&gt; and pass in the local directory name and the GCS bucket name.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ pwd
/Users/funuser/go/src/github.com/kubernetes/helm
$ scripts/sync-repo.sh fantastic-charts/ fantastic-charts
Getting ready to sync your local directory (fantastic-charts/) to a remote repository at gs://fantastic-charts
Verifying Prerequisites....
Thumbs up! Looks like you have gsutil. Let&#39;s continue.
Building synchronization state...
Starting synchronization
Would copy file://fantastic-charts/alpine-0.1.0.tgz to gs://fantastic-charts/alpine-0.1.0.tgz
Would copy file://fantastic-charts/index.yaml to gs://fantastic-charts/index.yaml
Are you sure you would like to continue with these changes?? [y/N]} y
Building synchronization state...
Starting synchronization
Copying file://fantastic-charts/alpine-0.1.0.tgz [Content-Type=application/x-tar]...
Uploading   gs://fantastic-charts/alpine-0.1.0.tgz:              740 B/740 B
Copying file://fantastic-charts/index.yaml [Content-Type=application/octet-stream]...
Uploading   gs://fantastic-charts/index.yaml:                    347 B/347 B
Congratulations your remote chart repository now matches the contents of fantastic-charts/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;updating-your-chart-repository&#34;&gt;Updating your chart repository&lt;/h2&gt;

&lt;p&gt;You&amp;rsquo;ll want to keep a local copy of the contents of your chart repository or use &lt;code&gt;gsutil rsync&lt;/code&gt; to copy the contents of your remote chart repository to a local directory.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-console&#34;&gt;$ gsutil rsync -d -n gs://bucket-name local-dir/    # the -n flag does a dry run
Building synchronization state...
Starting synchronization
Would copy gs://bucket-name/alpine-0.1.0.tgz to file://local-dir/alpine-0.1.0.tgz
Would copy gs://bucket-name/index.yaml to file://local-dir/index.yaml

$ gsutil rsync -d gs://bucket-name local-dir/       # performs the copy actions
Building synchronization state...
Starting synchronization
Copying gs://bucket-name/alpine-0.1.0.tgz...
Downloading file://local-dir/alpine-0.1.0.tgz:                        740 B/740 B
Copying gs://bucket-name/index.yaml...
Downloading file://local-dir/index.yaml:                              346 B/346 B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Helpful Links:
* Documentation on &lt;a href=&#34;https://cloud.google.com/storage/docs/gsutil/commands/rsync#description&#34;&gt;gsutil rsync&lt;/a&gt;
* &lt;a href=&#34;./#developing_charts&#34;&gt;The Chart Repository Guide&lt;/a&gt;
* Documentation on &lt;a href=&#34;https://cloud.google.com/storage/docs/gsutil/addlhelp/ObjectVersioningandConcurrencyControl#overview&#34;&gt;object versioning and concurrency control&lt;/a&gt; in Google Cloud Storage&lt;/p&gt;

&lt;h1 id=&#34;helm-provenance-and-integrity&#34;&gt;Helm Provenance and Integrity&lt;/h1&gt;

&lt;p&gt;Helm has provenance tools which help chart users verify the integrity and origin
of a package. Using industry-standard tools based on PKI, GnuPG, and well-respected
package managers, Helm can generate and verify signature files.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;
Version 2.0.0-alpha.4 introduced a system for verifying the authenticity of charts.
While we do not anticipate that any major changes will be made to the file formats
or provenancing algorithms, this portion of Helm is not considered &lt;em&gt;frozen&lt;/em&gt; until
2.0.0-RC1 is released. The original plan for this feature can be found
&lt;a href=&#34;https://github.com/kubernetes/helm/issues/983&#34;&gt;at issue 983&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;Integrity is established by comparing a chart to a provenance record. Provenance
records are stored in &lt;em&gt;provenance files&lt;/em&gt;, which are stored alongside a packaged
chart. For example, if a chart is named &lt;code&gt;myapp-1.2.3.tgz&lt;/code&gt;, its provenance file
will be &lt;code&gt;myapp-1.2.3.tgz.prov&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Provenance files are generated at packaging time (&lt;code&gt;helm package --sign ...&lt;/code&gt;), and
can be checked by multiple commands, notable &lt;code&gt;helm install --verify&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-workflow&#34;&gt;The Workflow&lt;/h2&gt;

&lt;p&gt;This section describes a potential workflow for using provenance data effectively.&lt;/p&gt;

&lt;p&gt;Prerequisites:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A valid PGP keypair in a binary (not ASCII-armored) format&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;helm&lt;/code&gt; command line tool&lt;/li&gt;
&lt;li&gt;GnuPG command line tools (optional)&lt;/li&gt;
&lt;li&gt;Keybase command line tools (optional)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; If your PGP private key has a passphrase, you will be prompted to enter
that passphrase for any commands that support the &lt;code&gt;--sign&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;Creating a new chart is the same as before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm create mychart
Creating mychart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once ready to package, add the &lt;code&gt;--sign&lt;/code&gt; flag to &lt;code&gt;helm package&lt;/code&gt;. Also, specify
the name under which the signing key is known and the keyring containing the corresponding private key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm package --sign --key &#39;helm signing key&#39; --keyring path/to/keyring.secret mychart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;TIP:&lt;/strong&gt; for GnuPG users, your secret keyring is in &lt;code&gt;~/.gnupg/secring.gpg&lt;/code&gt;. You can
use &lt;code&gt;gpg --list-secret-keys&lt;/code&gt; to list the keys you have.&lt;/p&gt;

&lt;p&gt;At this point, you should see both &lt;code&gt;mychart-0.1.0.tgz&lt;/code&gt; and &lt;code&gt;mychart-0.1.0.tgz.prov&lt;/code&gt;.
Both files should eventually be uploaded to your desired chart repository.&lt;/p&gt;

&lt;p&gt;You can verify a chart using &lt;code&gt;helm verify&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm verify mychart-0.1.0.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A failed verification looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm verify topchart-0.1.0.tgz
Error: sha256 sum does not match for topchart-0.1.0.tgz: &amp;quot;sha256:1939fbf7c1023d2f6b865d137bbb600e0c42061c3235528b1e8c82f4450c12a7&amp;quot; != &amp;quot;sha256:5a391a90de56778dd3274e47d789a2c84e0e106e1a37ef8cfa51fd60ac9e623a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To verify during an install, use the &lt;code&gt;--verify&lt;/code&gt; flag.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm install --verify mychart-0.1.0.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the keyring (containing the public key associated with the signed chart) is not in the default location, you may need to point to the
keyring with &lt;code&gt;--keyring PATH&lt;/code&gt; as in the &lt;code&gt;helm package&lt;/code&gt; example.&lt;/p&gt;

&lt;p&gt;If verification fails, the install will be aborted before the chart is even pushed
up to Tiller.&lt;/p&gt;

&lt;h3 id=&#34;using-keybase-io-credentials&#34;&gt;Using Keybase.io credentials&lt;/h3&gt;

&lt;p&gt;The &lt;a href=&#34;https://keybase.io&#34;&gt;Keybase.io&lt;/a&gt; service makes it easy to establish a chain of
trust for a cryptographic identity. Keybase credentials can be used to sign charts.&lt;/p&gt;

&lt;p&gt;Prerequisites:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A configured Keybase.io account&lt;/li&gt;
&lt;li&gt;GnuPG installed locally&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;keybase&lt;/code&gt; CLI installed locally&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;signing-packages&#34;&gt;Signing packages&lt;/h4&gt;

&lt;p&gt;The first step is to import your keybase keys into your local GnuPG keyring:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ keybase pgp export -s | gpg --import
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will convert your Keybase key into the OpenPGP format, and then import it
locally into your &lt;code&gt;~/.gnupg/secring.gpg&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;You can double check by running &lt;code&gt;gpg --list-secret-keys&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gpg --list-secret-keys                                                                                                       1 ↵
/Users/mattbutcher/.gnupg/secring.gpg
-------------------------------------
sec   2048R/1FC18762 2016-07-25
uid                  technosophos (keybase.io/technosophos) &amp;lt;technosophos@keybase.io&amp;gt;
ssb   2048R/D125E546 2016-07-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that your secret key will have an identifier string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;technosophos (keybase.io/technosophos) &amp;lt;technosophos@keybase.io&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is the full name of your key.&lt;/p&gt;

&lt;p&gt;Next, you can package and sign a chart with &lt;code&gt;helm package&lt;/code&gt;. Make sure you use at
least part of that name string in &lt;code&gt;--key&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm package --sign --key technosophos --keyring ~/.gnupg/secring.gpg mychart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a result, the &lt;code&gt;package&lt;/code&gt; command should produce both a &lt;code&gt;.tgz&lt;/code&gt; file and a &lt;code&gt;.tgz.prov&lt;/code&gt;
file.&lt;/p&gt;

&lt;h4 id=&#34;verifying-packages&#34;&gt;Verifying packages&lt;/h4&gt;

&lt;p&gt;You can also use a similar technique to verify a chart signed by someone else&amp;rsquo;s
Keybase key. Say you want to verify a package signed by &lt;code&gt;keybase.io/technosophos&lt;/code&gt;.
To do this, use the &lt;code&gt;keybase&lt;/code&gt; tool:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ keybase follow technosophos
$ keybase pgp pull
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first command above tracks the user &lt;code&gt;technosophos&lt;/code&gt;. Next &lt;code&gt;keybase pgp pull&lt;/code&gt;
downloads the OpenPGP keys of all of the accounts you follow, placing them in
your GnuPG keyring (&lt;code&gt;~/.gnupg/pubring.gpg&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;At this point, you can now use &lt;code&gt;helm verify&lt;/code&gt; or any of the commands with a &lt;code&gt;--verify&lt;/code&gt;
flag:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm verify somechart-1.2.3.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reasons-a-chart-may-not-verify&#34;&gt;Reasons a chart may not verify&lt;/h3&gt;

&lt;p&gt;These are common reasons for failure.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The prov file is missing or corrupt. This indicates that something is misconfigured
or that the original maintainer did not create a provenance file.&lt;/li&gt;
&lt;li&gt;The key used to sign the file is not in your keyring. This indicate that the
entity who signed the chart is not someone you&amp;rsquo;ve already signaled that you trust.&lt;/li&gt;
&lt;li&gt;The verification of the prov file failed. This indicates that something is wrong
with either the chart or the provenance data.&lt;/li&gt;
&lt;li&gt;The file hashes in the provenance file do not match the hash of the archive file. This
indicates that the archive has been tampered with.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If a verification fails, there is reason to distrust the package.&lt;/p&gt;

&lt;h2 id=&#34;the-provenance-file&#34;&gt;The Provenance File&lt;/h2&gt;

&lt;p&gt;The provenance file contains a chart’s YAML file plus several pieces of
verification information. Provenance files are designed to be automatically
generated.&lt;/p&gt;

&lt;p&gt;The following pieces of provenance data are added:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The chart file (Chart.yaml) is included to give both humans and tools an easy
view into the contents of the chart.&lt;/li&gt;
&lt;li&gt;The signature (SHA256, just like Docker) of the chart package (the .tgz file)
is included, and may be used to verify the integrity of the chart package.&lt;/li&gt;
&lt;li&gt;The entire body is signed using the algorithm used by PGP (see
[&lt;a href=&#34;http://keybase.io&#34;&gt;http://keybase.io&lt;/a&gt;] for an emerging way of making crypto signing and
verification easy).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The combination of this gives users the following assurances:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The package itself has not been tampered with (checksum package tgz).&lt;/li&gt;
&lt;li&gt;The entity who released this package is known (via the GnuPG/PGP signature).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The format of the file looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-----BEGIN PGP SIGNED MESSAGE-----
name: nginx
description: The nginx web server as a replication controller and service pair.
version: 0.5.1
keywords:
  - https
  - http
  - web server
  - proxy
source:
- https://github.com/foo/bar
home: http://nginx.com

...
files:
        nginx-0.5.1.tgz: “sha256:9f5270f50fc842cfcb717f817e95178f”
-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (GNU/Linux)

iEYEARECAAYFAkjilUEACgQkB01zfu119ZnHuQCdGCcg2YxF3XFscJLS4lzHlvte
WkQAmQGHuuoLEJuKhRNo+Wy7mhE7u1YG
=eifq
-----END PGP SIGNATURE-----
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the YAML section contains two documents (separated by &lt;code&gt;...\n&lt;/code&gt;). The
first is the Chart.yaml. The second is the checksums, a map of filenames to
SHA-256 digests (value shown is fake/truncated)&lt;/p&gt;

&lt;p&gt;The signature block is a standard PGP signature, which provides &lt;a href=&#34;http://www.rossde.com/PGP/pgp_signatures.html&#34;&gt;tamper
resistance&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;chart-repositories-1&#34;&gt;Chart Repositories&lt;/h2&gt;

&lt;p&gt;Chart repositories serve as a centralized collection of Helm charts.&lt;/p&gt;

&lt;p&gt;Chart repositories must make it possible to serve provenance files over HTTP via
a specific request, and must make them available at the same URI path as the chart.&lt;/p&gt;

&lt;p&gt;For example, if the base URL for a package is &lt;code&gt;https://example.com/charts/mychart-1.2.3.tgz&lt;/code&gt;,
the provenance file, if it exists, MUST be accessible at &lt;code&gt;https://example.com/charts/mychart-1.2.3.tgz.prov&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;From the end user&amp;rsquo;s perspective, &lt;code&gt;helm install --verify myrepo/mychart-1.2.3&lt;/code&gt;
should result in the download of both the chart and the provenance file with no
additional user configuration or action.&lt;/p&gt;

&lt;h2 id=&#34;establishing-authority-and-authenticity&#34;&gt;Establishing Authority and Authenticity&lt;/h2&gt;

&lt;p&gt;When dealing with chain-of-trust systems, it is important to be able to
establish the authority of a signer. Or, to put this plainly, the system
above hinges on the fact that you trust the person who signed the chart.
That, in turn, means you need to trust the public key of the signer.&lt;/p&gt;

&lt;p&gt;One of the design decisions with Kubernetes Helm has been that the Helm
project would not insert itself into the chain of trust as a necessary
party. We don&amp;rsquo;t want to be &amp;ldquo;the certificate authority&amp;rdquo; for all chart
signers. Instead, we strongly favor a decentralized model, which is part
of the reason we chose OpenPGP as our foundational technology.
So when it comes to establishing authority, we have left this
step more-or-less undefined in Helm 2.0.0.&lt;/p&gt;

&lt;p&gt;However, we have some pointers and recommendations for those interested
in using the provenance system:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;a href=&#34;https://keybase.io&#34;&gt;Keybase&lt;/a&gt; platform provides a public
centralized repository for trust information.

&lt;ul&gt;
&lt;li&gt;You can use Keybase to store your keys or to get the public keys of others.&lt;/li&gt;
&lt;li&gt;Keybase also has fabulous documentation available&lt;/li&gt;
&lt;li&gt;While we haven&amp;rsquo;t tested it, Keybase&amp;rsquo;s &amp;ldquo;secure website&amp;rdquo; feature could
be used to serve Helm charts.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://github.com/kubernetes/charts&#34;&gt;official Kubernetes Charts project&lt;/a&gt;
is trying to solve this problem for the official chart repository.

&lt;ul&gt;
&lt;li&gt;There is a long issue there &lt;a href=&#34;https://github.com/kubernetes/charts/issues/23&#34;&gt;detailing the current thoughts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The basic idea is that an official &amp;ldquo;chart reviewer&amp;rdquo; signs charts with
her or his key, and the resulting provenance file is then uploaded
to the chart repository.&lt;/li&gt;
&lt;li&gt;There has been some work on the idea that a list of valid signing
keys may be included in the &lt;code&gt;index.yaml&lt;/code&gt; file of a repository.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, chain-of-trust is an evolving feature of Helm, and some
community members have proposed adapting part of the OSI model for
signatures. This is an open line of inquiry in the Helm team. If you&amp;rsquo;re
interested, jump on in.&lt;/p&gt;

&lt;h1 id=&#34;chart-tests&#34;&gt;Chart Tests&lt;/h1&gt;

&lt;p&gt;A chart contains a number of Kubernetes resources and components that work together. As a chart author, you may want to write some tests that validate that your chart works as expected when it is installed. These tests also help the chart consumer understand what your chart is supposed to do.&lt;/p&gt;

&lt;p&gt;A &lt;strong&gt;test&lt;/strong&gt; in a helm chart lives under the &lt;code&gt;templates/&lt;/code&gt; directory and is a pod definition that specifies a container with a given command to run. The container should exit successfully (exit 0) for a test to be considered a success. The pod definition must contain one of the helm test hook annotations: &lt;code&gt;helm.sh/hooks: test-success&lt;/code&gt; or &lt;code&gt;helm.sh/hooks: test-failure&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Example tests:
- Validate that your configuration from the values.yaml file was properly injected.
  - Make sure your username and password work correctly
  - Make sure an incorrect username and password does not work
- Assert that your services are up and correctly load balancing
- etc.&lt;/p&gt;

&lt;p&gt;You can run the pre-defined tests in Helm on a release using the command &lt;code&gt;helm test &amp;lt;RELEASE_NAME&amp;gt;&lt;/code&gt;. For a chart consumer, this is a great way to sanity check that their release of a chart (or application) works as expected.&lt;/p&gt;

&lt;h2 id=&#34;a-breakdown-of-the-helm-test-hooks&#34;&gt;A Breakdown of the Helm Test Hooks&lt;/h2&gt;

&lt;p&gt;In Helm, there are two test hooks: &lt;code&gt;test-success&lt;/code&gt; and &lt;code&gt;test-failure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;test-success&lt;/code&gt; indicates that test pod should complete successfully. In other words, the containers in the pod should exit 0.
&lt;code&gt;test-failure&lt;/code&gt; is a way to assert that a test pod should not complete successfully. If the containers in the pod do not exit 0, that indicates success.&lt;/p&gt;

&lt;h2 id=&#34;example-test&#34;&gt;Example Test&lt;/h2&gt;

&lt;p&gt;Here is an example of a helm test pod definition in an example mariadb chart:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mariadb/
  Chart.yaml
  README.md
  values.yaml
  charts/
  templates/
  templates/tests/test-mariadb-connection.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;wordpress/templates/tests/test-mariadb-connection.yaml&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: &amp;quot;{{ .Release.Name }}-credentials-test&amp;quot;
  annotations:
    &amp;quot;helm.sh/hook&amp;quot;: test-success
spec:
  containers:
  - name: {{ .Release.Name }}-credentials-test
    image: {{ .Values.image }}
    env:
      - name: MARIADB_HOST
        value: {{ template &amp;quot;mariadb.fullname&amp;quot; . }}
      - name: MARIADB_PORT
        value: &amp;quot;3306&amp;quot;
      - name: WORDPRESS_DATABASE_NAME
        value: {{ default &amp;quot;&amp;quot; .Values.mariadb.mariadbDatabase | quote }}
      - name: WORDPRESS_DATABASE_USER
        value: {{ default &amp;quot;&amp;quot; .Values.mariadb.mariadbUser | quote }}
      - name: WORDPRESS_DATABASE_PASSWORD
        valueFrom:
          secretKeyRef:
            name: {{ template &amp;quot;mariadb.fullname&amp;quot; . }}
            key: mariadb-password
    command: [&amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;mysql --host=$MARIADB_HOST --port=$MARIADB_PORT --user=$WORDPRESS_DATABASE_USER --password=$WORDPRESS_DATABASE_PASSWORD&amp;quot;]
  restartPolicy: Never
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;steps-to-run-a-test-suite-on-a-release&#34;&gt;Steps to Run a Test Suite on a Release&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;$ helm install mariadb&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NAME:   quirky-walrus
LAST DEPLOYED: Mon Feb 13 13:50:43 2017
NAMESPACE: default
STATUS: DEPLOYED
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;$ helm test quirky-walrus&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;RUNNING: quirky-walrus-credentials-test
SUCCESS: quirky-walrus-credentials-test
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;You can define as many tests as you would like in a single yaml file or spread across several yaml files in the &lt;code&gt;templates/&lt;/code&gt; directory&lt;/li&gt;
&lt;li&gt;You are welcome to nest your test suite under a &lt;code&gt;tests/&lt;/code&gt; directory like &lt;code&gt;&amp;lt;chart-name&amp;gt;/templates/tests/&lt;/code&gt; for more isolation&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;chart-repositories-frequently-asked-questions&#34;&gt;Chart Repositories: Frequently Asked Questions&lt;/h1&gt;

&lt;p&gt;This section tracks some of the more frequently encountered issues with using chart repositories.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We&amp;rsquo;d love your help&lt;/strong&gt; making this document better. To add, correct, or remove
information, &lt;a href=&#34;https://github.com/kubernetes/helm/issues&#34;&gt;file an issue&lt;/a&gt; or
send us a pull request.&lt;/p&gt;

&lt;h2 id=&#34;fetching&#34;&gt;Fetching&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Q: Why do I get a &lt;code&gt;unsupported protocol scheme &amp;quot;&amp;quot;&lt;/code&gt; error when trying to fetch a chart from my custom repo?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A: (Helm &amp;lt; 2.5.0) This is likely caused by you creating your chart repo index without specifying the &lt;code&gt;--url&lt;/code&gt; flag.
Try recreating your &lt;code&gt;index.yaml&lt;/code&gt; file with a command like &lt;code&gt;helm repo index --url http://my-repo/charts .&lt;/code&gt;,
and then re-uploading it to your custom charts repo.&lt;/p&gt;

&lt;p&gt;This behavior was changed in Helm 2.5.0.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
